use bevy::prelude::*;

use bevy_rapier2d::prelude::*;

//use bevy::sprite::collide_aabb::{collide, Collision};

use crate::components::{
    Alive, ColliderSquare, Enemy, EnemyCount, GameTextures, Health, OnGameScreenMarker, Player,
    ARENA_SIZE, ENEMY_BOOMER_SPRITE_SIZE, ENEMY_CRAWLER_SPRITE_SIZE, ENEMY_ZOOMER_SPRITE_SIZE,
    MAX_NUM_ENEMIES, TILE_SIZE, TYPES_OF_ENEMIES,
};

use rand::Rng;

pub fn _spawn_enemy(mut commands: Commands, asset_server: Res<AssetServer>) {
    let off_set = 30.0;

    let mut rng = rand::thread_rng();
    let x = rng.gen_range(-640.0..640.0);
    let y = rng.gen_range(-360.0..360.0);

    commands.spawn((
        SpriteBundle {
            transform: Transform::from_xyz(x, y, 10.0),
            texture: asset_server.load("graphic/boomer.png"),
            ..default()
        },
        Enemy {},
        ColliderSquare {
            dimension: Vec2::new(
                ENEMY_BOOMER_SPRITE_SIZE / 2.0 - off_set,
                ENEMY_BOOMER_SPRITE_SIZE / 2.0 - off_set,
            ),
        },
        Health { hp: 100 },
    ));
}

pub fn spawn_horde_of_enemies(
    mut commands: Commands,
    mut enemy_count: ResMut<EnemyCount>,
    game_textures: Res<GameTextures>,
) {
    let width = (ARENA_SIZE) / 2.0;
    let height = (ARENA_SIZE) / 2.0;
    let off_set = 25.0;

    let array = [
        game_textures.enemy_boomer.clone(),
        game_textures.enemy_crawler.clone(),
        game_textures.enemy_zoomer.clone(),
    ];
    let array_sprite_size = [
        ENEMY_BOOMER_SPRITE_SIZE,
        ENEMY_CRAWLER_SPRITE_SIZE,
        ENEMY_ZOOMER_SPRITE_SIZE,
    ];

    for _i in 0..MAX_NUM_ENEMIES {
        let mut rng = rand::thread_rng();
        let enemy_type = rng.gen_range(0..TYPES_OF_ENEMIES);
        let x = rng.gen_range(-width + TILE_SIZE..width - TILE_SIZE);
        let y = rng.gen_range(-height + TILE_SIZE..height - TILE_SIZE);

        // array of enemies textures so I can circle through them using numbers generated by rng

        commands
            .spawn((
                SpriteBundle {
                    transform: Transform::from_xyz(x, y, 10.0),
                    texture: array[enemy_type].clone(),
                    ..default()
                },
                Enemy {},
                RigidBody::Dynamic,
                Collider::cuboid(
                    array_sprite_size[enemy_type] / 2.0_f32 - off_set,
                    array_sprite_size[enemy_type] / 2.0_f32 - off_set,
                ),
                ColliderSquare {
                    dimension: Vec2::new(
                        array_sprite_size[enemy_type] / 2.0 + off_set,
                        array_sprite_size[enemy_type] / 2.0 + off_set,
                    ),
                },
                Alive(true),
                Health { hp: 100 },
                OnGameScreenMarker,
            ))
            .insert(Damping {
                linear_damping: 15.0,
                angular_damping: 10.0,
            });
        // update enemy count
        enemy_count.0 += 1;
    }
}

pub fn update_enemy(
    mut enemy_query: Query<(Entity, &mut Transform), (With<Enemy>, Without<Player>)>,
    player_query: Query<&Transform, With<Player>>,
) {
    // chase the player
    for (_enemy_entity, mut enemy_transform) in enemy_query.iter_mut() {
        for player_transform in player_query.iter() {
            let mut direction = player_transform.translation - enemy_transform.translation;
            direction = direction.normalize();
            enemy_transform.translation += direction * 2.0;

            //let enemy face the player
            let angle = direction.y.atan2(direction.x);
            enemy_transform.rotation = Quat::from_rotation_z(angle);
        }
    }
}
/*  Don\t need this anymore because rapier takes care of it.

pub fn check_collision_between_enemies(
    mut query_enemy: Query<(Entity, &mut Transform, &mut ColliderSquare), With<Enemy>>,
) {
    let mut iter = query_enemy.iter_combinations_mut();
    while let Some([ enemy_a, mut enemy_b]) = iter.fetch_next() {
        // Handle collisions between entities with enemies.

        let collision = collide(
            enemy_a.1.translation,
            enemy_a.2.dimension,
            enemy_b.1.translation,
            enemy_b.2.dimension,
        );

        match collision {
            Some(Collision::Top) => {
                // set translatoion
                enemy_b.1.translation.y += 75.0;
            }
            Some(Collision::Bottom) => {
                // Despawn both entities
                enemy_b.1.translation.y -= 75.0;
            }

            Some(Collision::Left) => {
                // Despawn both entities
                enemy_b.1.translation.x -= 75.0;
            }

            Some(Collision::Right) => {
                // Despawn both entities
                enemy_b.1.translation.x += 75.0;
            }

            Some(Collision::Inside) => {
                // Despawn both entities
                print!("Inside");
            }
            None => {}
        }
    }
}
*/
